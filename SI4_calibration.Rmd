---
title: "Calibration of the TROLL model in French Guiana"
output: 
  bookdown::html_document2:
    number_sections: false  
    toc: true
    toc_float: yes
  bookdown::word_document2:
    reference_docx: ./template/template.docx
  bookdown::pdf_document2:
    includes:
      before_body: ./template/doc_prefix.tex
      in_header: ./template/preamble.tex
    number_sections: false
    toc: false
    keep_tex: no
linestretch: 1.5
csl: bibliography/mee.csl
bibliography: bibliography/library.bib
link-citations: yes
---
Guillaume Salzet$^{1,2}$

*$^1$ INRAE, UMR BETA, 54042 Nancy, France;*
*$^2$ INRAE, UMR EcoFoG (Agroparistech, Cirad, CNRS, Université des Antilles, Université de la Guyane), Campus Agronomique, 97310 Kourou, French Guiana;*

# Introduction

Forest modelling aims to reproduce at a given scale of space and time emergent properties from sub-entities. Classically these entities in gap-models are cohorts of trees or for D(G)VM these are representative plant functional types. The underlying hypothesis is small scale interaction between entities can reproduce global patterns. In case of TROLL this hypothesis is furthermore implied with the use of individual ecophysiological processes. 

However, all this models rely on complex implementation and use high level of resources (time of computation) to provide results at their designed scale. Working with such complex models create challenges :
 * Simulations are time consuming and require the use of High Performance Computers when replicates are needed;
 * Model calibration are very complicated due to unpredictability of behaviour's model. This task need two steps to achieve calibration : a sensitivity analysis to select adapted parameters and a model inversion to selection which parameters of the model are more likely to produce observed outputs;
 * Model prediction need to assess uncertainties produced by the model. This goal imply to select calibration methods that allow to use calibrated-model in a reverse and forward uncertainty propagation.
 
 Among the present literature in meta-modelling, we decide to interface TROLL through rcontroll to a meta-modelling package hetGP in R. The advantages of heteroskedastic gaussian processes modelling is their robustness to complex noise structure depending to inputs' model. The provided surrogate models can be easily used in a forward modelling approach to assess sensitivy of parameters and in a reverse modelling approach to calibrate using observed outputs.
 
 Moreover the sequential design included in this package optimise the input selection, thus the computing ressource, so as to get efficiently the heteroskedastic structure of the error.

# Materials and methods

* autocalibGP function:

```{r calibration functions}
source("SI5_calibration_functions.R")

ls()
```



# Results

```{r Standard_LHS}

parameters <- c("klight","phi","g1","fallocwood","falloccanopy","m","vC","Cseedrain","log10nbs0","Hmaxcor","CR_a","CR_b","m1","DBHmaxcor","ahCorr")
lower <- c(0.1,1E-2,2,1E-2,1E-2,1E-2,1E-2,1E-2,0,1E-1,1.5,0.4,1,0.5,0)
upper = c(1,0.2-1E-2,5,1,1,0.05,0.15,1E5,2,1.9,3,0.8,1.2,1.5,1)
global_parameters_boundaries <- data.frame("parameter" = parameters,"lower" = lower,
"upper" = upper)

global_parameters_boundaries
```

```{r example_LHS}
global_parameters_boundaries$lower[c(1:10,13:15)] <- NA
global_parameters_boundaries$upper[c(1:10,13:15)] <- NA

global_parameters_boundaries
```

```{r data_LHS eval=FALSE, include=TRUE}
library(rcontroll)
library(tidyverse)
library(raster)
library(doSNOW)
LHS_design <- Generate_LHS_Autocalib(nsim = 250,nreplicat = 3,nparam = 2,paramLHS = global_parameters_boundaries,Nyears = 1000,Nsampling = 100)

Generated_parameters <- Generate_parameters_autocalib(LHS_design = LHS_design)
```


```{r eval=FALSE, include=TRUE}
calib_dataset <- autocalibGP(Generated_parameters = Generated_parameters,PATH = getwd(),ncores_sim = 100,ncores = 10,NiterHetGP = NULL,initj = 1,Jrefresh = 25)
```

```{r eval=FALSE, include=TRUE}
library(sensitivity)

morrisOut <- morris(
  model = NULL,
  factors = calib_dataset$params, 
  r = 500, 
  design = list(type = "oat", levels = 20, grid.jump = 3), 
  binf = 0, 
  bsup = 1, 
  scale = FALSE)

Y <- matrix(c(predict(calib_dataset$GPmodels$RateDBH$mod.RateDBH,morrisOut[['X']])$mean,
       predict(calib_dataset$GPmodels$MeanAgb$mod.MeanAgb,morrisOut[['X']])$mean,
       predict(calib_dataset$GPmodels$MeanSum10$mod.MeanSum10,morrisOut[['X']])$mean,
       predict(calib_dataset$GPmodels$MeanSum30$mod.MeanSum30,morrisOut[['X']])$mean,
       predict(calib_dataset$GPmodels$MeanGpp$mod.MeanGpp,morrisOut[['X']])$mean,
       predict(calib_dataset$GPmodels$MeanNpp$mod.MeanNpp,morrisOut[['X']])$mean,
       predict(calib_dataset$GPmodels$MeanBa10$mod.MeanBa10,morrisOut[['X']])$mean,
       predict(calib_dataset$GPmodels$MeanHill$mod.MeanHill,morrisOut[['X']])$mean,
       predict(calib_dataset$GPmodels$MeanRao$mod.MeanRao,morrisOut[['X']])$mean,
       predict(calib_dataset$GPmodels$Hmean$mod.Hmean,morrisOut[['X']])$mean,
       predict(calib_dataset$GPmodels$Lambda1ter$mod.Lambda1ter,morrisOut[['X']])$mean,
       predict(calib_dataset$GPmodels$VolECMP$mod.VolECMP,morrisOut[['X']])$mean,
       predict(calib_dataset$GPmodels$VolECMPS$mod.VolECMPS,morrisOut[['X']])$mean,
       predict(calib_dataset$GPmodels$GmDBH$mod.GmDBH,morrisOut[['X']])$mean), ncol = 14, byrow = FALSE)

tell(morrisOut,Y)

# summarise the moris output
morrisOut.df <- data.frame(
  parameter = calib_dataset$params,
  mu.star = apply(abs(morrisOut$ee), 2, mean, na.rm = T),
  sigma = apply(morrisOut$ee, 2, sd, na.rm = T)
) %>%
  arrange( mu.star )

```

```{r}
load("rcontrollTROLL_calib_250x3LHS_1000y.rda")
```

```{r}
morrisOut.df %>%
  gather(variable, value, -parameter) %>%
  ggplot(aes(reorder(parameter, value), value, fill = variable), color = NA)+
  geom_bar(position = position_dodge(), stat = 'identity') +
  scale_fill_brewer("", labels = c('mu.star' = expression(mu * "*"), 'sigma' = expression(sigma)), palette="Dark2") +
  theme_classic() +
  theme(
    axis.text = element_text(size = 6),
    axis.text.x = element_text(angle=90, hjust=1, vjust = 0.5),
    axis.title = element_blank(),
    legend.position = c(0.05 ,0.95),legend.justification = c(0.05,0.95)
  )
```

```{r}
library(tgp)

sf <- tgp::sens(X = as_tibble(calib_dataset$XGP),calib_dataset$Y[,20], nn.lhs=1000, model=bgp, verb=1)

plot(sf, layout="sens", legendloc="topleft")

plot(sf, layout="sens", maineff=t(1:dim(calib_dataset$XGP)[2]))
```

```{r}
cols <- hcl.colors(n = 128, palette = "viridis")

resolution <- 250
xgrid <- matrix(c(rep(seq(0,
             1, length=resolution), each = resolution),
             rep(seq(0,
             1, length=resolution), times = resolution)),nrow = resolution^2,byrow = FALSE)

p.a <- predict(calib_dataset$GPmodels$VolECMP$mod.VolECMP,xgrid)

pvar.a <- p.a$sd2 + p.a$nugs

x_CR_a <- seq(global_parameters_boundaries$lower[global_parameters_boundaries$parameter == calib_dataset$params[1]],
             global_parameters_boundaries$upper[global_parameters_boundaries$parameter == calib_dataset$params[1]], length=resolution)

x_CR_b <- seq(global_parameters_boundaries$lower[global_parameters_boundaries$parameter == calib_dataset$params[2]],
             global_parameters_boundaries$upper[global_parameters_boundaries$parameter == calib_dataset$params[2]], length=resolution)

p.b <- predict(calib_dataset$GPmodels$VolECMP$mod.VolECMP,matrix(c(seq(0,1, length=resolution),rep(0.5,times = resolution)),nrow = resolution, byrow = FALSE))

p.c <- predict(calib_dataset$GPmodels$VolECMP$mod.VolECMP,matrix(c(rep(0.07,times = resolution),seq(0,1, length=resolution)),nrow = resolution, byrow = FALSE))


Mean_raster <- ggplot() + 
  geom_raster(aes(x = (global_parameters_boundaries$upper[global_parameters_boundaries$parameter == calib_dataset$params[1]] - global_parameters_boundaries$lower[global_parameters_boundaries$parameter == calib_dataset$params[1]])*xgrid[,1] + global_parameters_boundaries$lower[global_parameters_boundaries$parameter == calib_dataset$params[1]], y = (global_parameters_boundaries$upper[global_parameters_boundaries$parameter == calib_dataset$params[2]] - global_parameters_boundaries$lower[global_parameters_boundaries$parameter == calib_dataset$params[2]])*xgrid[,2] + global_parameters_boundaries$lower[global_parameters_boundaries$parameter == calib_dataset$params[2]], fill = matrix(p.a$mean,nrow = resolution,byrow = FALSE))) +
  geom_hline(aes(yintercept = 0.6), color = "red", linetype = "dashed") +
  geom_vline(aes(xintercept = 1.60), color = "blue", linetype = "dashed")+
  scale_fill_viridis_c()+
  xlab("Crown Radius parameter a") + ylab("Crown Radius parameter b")+
  guides(fill = guide_legend(title = "Mean"))+
  theme_bw()

Sd_raster <- ggplot() + 
  geom_raster(aes(x = (global_parameters_boundaries$upper[global_parameters_boundaries$parameter == calib_dataset$params[1]] - global_parameters_boundaries$lower[global_parameters_boundaries$parameter == calib_dataset$params[1]])*xgrid[,1] + global_parameters_boundaries$lower[global_parameters_boundaries$parameter == calib_dataset$params[1]], y = (global_parameters_boundaries$upper[global_parameters_boundaries$parameter == calib_dataset$params[2]] - global_parameters_boundaries$lower[global_parameters_boundaries$parameter == calib_dataset$params[2]])*xgrid[,2] + global_parameters_boundaries$lower[global_parameters_boundaries$parameter == calib_dataset$params[2]], 
                  fill = matrix(sqrt(pvar.a),nrow = resolution,byrow = FALSE))) +
  scale_fill_viridis_c()+
  geom_hline(aes(yintercept = 0.6), color = "red", linetype = "dashed")+
  geom_vline(aes(xintercept = 1.60), color = "blue", linetype = "dashed")+
  xlab("Crown Radius parameter a") + ylab("Crown Radius parameter b")+
  guides(fill = guide_legend(title = "Sd"))+
  theme_bw()

Extract_plot_y <- ggplot() + 
  geom_point(aes(x = as_tibble(calib_dataset$X)$CR_a, y = as_tibble(calib_dataset$Y)$Vol_ECMP, 
                 color = (abs(0.5 - as_tibble(calib_dataset$XGP)$CR_b)<0.05) )) + 
  geom_ribbon(aes(x= x_CR_a, ymin = qnorm(0.05, p.b$mean, sqrt(p.b$sd2 + p.b$nugs)),
                                 ymax = qnorm(0.95, p.b$mean, sqrt(p.b$sd2 + p.b$nugs))), alpha = 0.1, color = "red") +
  geom_line(aes(x = x_CR_a, y = p.b$mean)) +
  scale_color_manual(values=c("lightgrey",'red'),labels = c("F", "T"))+
  xlab("Crown Radius parameter a") + ylab("Volume ECMP")+
  guides(color = guide_legend(title = "||CR b - 0.5|| < 5% LHS"))+
  theme_bw()

Extract_plot_x <- ggplot() + 
  geom_point(aes(x = as_tibble(calib_dataset$X)$CR_b, y = as_tibble(calib_dataset$Y)$Vol_ECMP, 
                 color = (abs(0.07 - as_tibble(calib_dataset$XGP)$CR_a)<0.05) )) + 
  geom_ribbon(aes(x= x_CR_b, ymin = qnorm(0.05, p.c$mean, sqrt(p.c$sd2 + p.c$nugs)),
                                 ymax = qnorm(0.95, p.c$mean, sqrt(p.c$sd2 + p.c$nugs))), alpha = 0.1, color = "red") +
  geom_line(aes(x = x_CR_b, y = p.c$mean)) +
  scale_color_manual(values=c("lightgrey",'blue'),labels = c("F", "T"))+
  xlab("Crown Radius parameter b") + ylab("Volume ECMP")+
  guides(color = guide_legend(title = "||CR a - 1.60|| < 5% LHS"))+
  theme_bw()

cowplot::plot_grid(Mean_raster,Sd_raster,
                   Extract_plot_y,Extract_plot_x,
                   labels = c('A', 'B','C','D'),
                    align="hv")



```


# Discussion

# References
